/* JORTESubscriptionCreate.c  */

/**
  * This code provides conversion between JAVA a C environments.
  * The C functions are calling here and results are send to JAVA
  * native functions. It uses the header pregenerated by JAVA
  * (by command 'javah -jni class_with_native_function')
  *
  * @author Lukas Pokorny (lukas_pokorny@centrum.cz)
  * @author CTU FEE Prague - Department of Control Engineering (dce.felk.cvut.cz)
  * @author Project ORTE - OCERA Real Time Ethernet (www.ocera.org)
  * @author dedication to Kj
  * @version 0.1
  *
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  */


#include <stdlib.h>
#include "jorte/getNtpTime.h"
// library header file's path
#include "orte.h"
// pregenerated header
#include "jorte/org_ocera_orte_Subscription.h"
// enable TEST_STAGE run level
#include "jorte/4all.h"

/*
typedef struct
{
 JavaVM        *jvm;
 jobject        obj;
 jobject        rinfo;
 int            value; // !! pro testovani
} JORTECallbackContext_t;


typedef struct
{
 jobject     obj_recvStatus;
 jobject     str_topic;
 jobject     str_type;
 jobject     obj_guid;
 jobject     obj_ntpT_loc;
 jobject     obj_ntpT_rem;
 jobject     obj_sn;
} RecvInfoVar_t;
*/
#include "jorte/typedefs_defines_jorte.h"

// ### recvCallBack() #########################################################

void
recvCallBack(const ORTERecvInfo *info,void *vinstance, void *recvCallBackParam)
{
//  char *instance=(char*)vinstance;

  JavaVM          *jvm;
  JNIEnv          *env = NULL; // local reference - Ok

  jclass           cls = 0; //! local reference

  jobject          obj = 0; //! local reference
  //jobject          obj_recvInfo = 0; //! local reference
  jobject          rinfo = 0; //! local reference
  jobject          obj_instance = 0;

  jmethodID        mid = 0; //! local reference
  jmethodID        mid_callback = 0; //! local reference

  jfieldID         fid = 0; //! local reference
  jstring          jstr;
  //RecvInfoVar_t       *recvInfoVar   = (RecvInfoVar_t*)malloc(sizeof(RecvInfoVar_t));

  JORTECallbackContext_t   *callback_cont = (JORTECallbackContext_t*)recvCallBackParam;

  int i = callback_cont->value++; // !! JEN PRO TESTOVACI UCELY





#ifdef TEST_STAGE
  printf("\n\n");
  printf(":c: --------------- spustena recvCallBack.. z Ccka ------------------\n");
#endif

  if(callback_cont->obj == 0) return;
  obj = callback_cont->obj;

  if(callback_cont->jvm == 0) return;
  jvm = callback_cont->jvm;

  rinfo = callback_cont->rinfo;




#ifdef TEST_STAGE
   printf(":c: recvCallBack:  jvm = %p \n", jvm);
   printf(":c: recvCallBack:  obj = %p \n", obj);
#endif

  // get env
  (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);
  if(!env)
  {
    printf(":!c: recvCallBack: can't get env..\n");
    return;
  }

#ifdef TEST_STAGE
   printf(":c: recvCallBack:  env = %p \n", env);
#endif

	// get class
    cls = (*env)->GetObjectClass(env,obj);
    if(cls == 0)
    {
      printf(":!c: cannot find callbackObj class..\n");
      return;
    }
    // create global reference

#ifdef TEST_STAGE
	printf(":c: recvCallBack:  volana fce GetMethodID().. \n");
#endif

	// get method ID
    mid = (*env)->GetMethodID(env,
                              cls,
                              "callback",
                              "(Lorg/ocera/orte/types/RecvInfo;Ljava/lang/Object;)V");
     	               //   "(Lorg/ocera/orte/types/RecvInfo;Ljava/lang/Object;)V");
	// create global reference to callback method
	if(mid == 0)
    {
      printf(":!c: can not find callback() method...\n");
      return;
    }
    mid_callback = mid;

#ifdef TEST_STAGE
   printf(":c: recvCallBack:          obj = %p \n", obj);
   printf(":c: recvCallBack:          cls = %p \n", cls);
   printf(":c: recvCallBack:          mid = %p \n", mid);
  //
#endif


// -- vytvoreni parametru callback funkce ---------------------------------------------
// vytvorit objekt RecvInfo - global ref


  // get object RecvInfo class
  cls = (*env)->FindClass(env, "org/ocera/orte/types/RecvInfo");
  if(!cls)
  {
    printf(":!c: cls RecvInfo class not found..\n");
    return; // ma se pri selhani RecvInfa davat tvrdy return?
  }

  // create RecvInfo object
  if (rinfo == 0)
  {
	// call object constructor
	mid = (*env)->GetMethodID(env, cls, "<init>", "()V");
	if(!mid)
	{
      printf(":!c: constructor RecvInfo() not found..\n");
      return; // ma se pri selhani RecvInfa davat tvrdy return?
	}
	// new object
	rinfo = (*env)->NewObject(env, cls, mid);
	if(!rinfo)
	{
      printf(":!c: obj_recvInfo not created..\n");
  	  return;
	}
    #ifdef TEST_STAGE
    	printf(":c: object RecvInfo created..\n");
    #endif
	// create global reference
    callback_cont->rinfo = (*env)->NewGlobalRef(env, rinfo);
	if (callback_cont->rinfo == 0)
    {
      printf(":!c: cannot create global reference callback_cont->rinfo ..\n");
      return;
    }
    #ifdef TEST_STAGE
    	printf(":c: global reference to object RecvInfo created..\n");
    #endif
  }



//--------------------------------------------------------------------
// set RecvInfo fields

#ifdef TEST_STAGE
//*** int i - testovaci
  // get field ID
  fid = (*env)->GetFieldID(env,cls,"i","I");
  if(fid == NULL)
  {
    printf(":!c: cannot get ReccvInfo.i fieldID..\n");
    return; // je toto nutne??
  }
  printf(":c: fid of ReccvInfo.i found..\n");
  // set new value '1234'
  (*env)->SetIntField(env,callback_cont->rinfo,fid,i++);
  printf(":c: kontrola prirazeni %d \n",
         (*env)->GetIntField(env,callback_cont->rinfo,fid));
  printf(":c: new value of RecvInfo.i set..\n");
#endif



//*** RecvStatus
    #ifdef TEST_STAGE
        printf("\n");
		printf(":c: ---- RecvInfo [odesilane]:\n");
    #endif

	// get method ID
    mid = (*env)->GetMethodID(env,
                              cls,
                              "setRecvStatus",
                              "(I)V");
	if(mid == 0)
    {
      printf(":!c: can not find setRecvStatus() method...\n");
      return;
    }
    // call method
	(*env)->CallVoidMethod(env,
                           callback_cont->rinfo,
	                       mid,
                           (jint)info->status);

//*** topic
    // Look for the instance field s in cls
    fid = (*env)->GetFieldID(env,
                             cls,
		  				     "topic",
						     "Ljava/lang/String;");
    if (fid == NULL)
	{
      printf(":!c: can not find 'topic' field ID...\n");
	  return; // failed to find the field
    }
    // Read the instance field s
	jstr = (*env)->GetObjectField(env, obj, fid);
    // Create a new string and overwrite the instance field
    jstr = (*env)->NewStringUTF(env, info->topic);
    if (jstr == NULL)
	{
	  return;
	  /* out of memory */
    }
    (*env)->SetObjectField(env, callback_cont->rinfo, fid, jstr);



//*** type
    // Look for the instance field s in cls
    fid = (*env)->GetFieldID(env,
                             cls,
		  				     "type",
						     "Ljava/lang/String;");
    if (fid == NULL)
	{
      printf(":!c: can not find 'type' field ID...\n");
	  return; // failed to find the field
    }
    // Read the instance field s
	jstr = (*env)->GetObjectField(env, obj, fid);
    // Create a new string and overwrite the instance field
    jstr = (*env)->NewStringUTF(env, info->type);
    if (jstr == NULL)
	{
      printf(":!c: can not set new value 'type'..\n");
	  return;
	  /* out of memory*/
    }
    (*env)->SetObjectField(env, callback_cont->rinfo, fid, jstr);



//*** GUID_RTPS
    mid = (*env)->GetMethodID(env,
                              cls,
                              "setSenderGuid",
                              "(JJJ)V");
	if(mid == 0)
    {
      printf(":!c: can not find setSenderGuid() method...\n");
      return;
    }
    // call method
	(*env)->CallVoidMethod(env,
                           callback_cont->rinfo,
	                       mid,
                           (jlong)info->senderGUID.hid,
                           (jlong)info->senderGUID.aid,
						   (jlong)info->senderGUID.oid);


//*** localTimeRecv
	// get method ID
    mid = (*env)->GetMethodID(env,
                              cls,
                              "setLocalTimeRecv",
                              "(IJ)V");
	if(mid == 0)
    {
      printf(":!c: can not find setLocalTimeRecv() method...\n");
      return;
    }
    // call method
	(*env)->CallVoidMethod(env,
                           callback_cont->rinfo,
	                       mid,
                           (jint) info->localTimeReceived.seconds,
                           (jlong)info->localTimeReceived.fraction);



//*** remoteTimePublished
	// get method ID
    mid = (*env)->GetMethodID(env,
                              cls,
                              "setRemoteTimePub",
                              "(IJ)V");
	if(mid == 0)
    {
      printf(":!c: can not find setRemoteTimePub() method...\n");
      return;
    }
    // call method
	(*env)->CallVoidMethod(env,
                           callback_cont->rinfo,
	                       mid,
                           (jint) info->remoteTimePublished.seconds,
                           (jlong)info->remoteTimePublished.fraction);


//*** Sequence number
	// get method ID
    mid = (*env)->GetMethodID(env,
                              cls,
                              "setSeqNumber",
                              "(II)V");
	if(mid == 0)
    {
      printf(":!c: can not find setSeqNumber() method...\n");
      return;
    }
    // call method
	(*env)->CallVoidMethod(env,
                           callback_cont->rinfo,
	                       mid,
                           info->sn.high,
                           info->sn.low);

    #ifdef TEST_STAGE
      printf(":c:    recvStatus: %d \n", info->status);
      printf(":c:    senderGuid: hid = %d, aid = %d, oid = %d \n",
	         info->senderGUID.hid,info->senderGUID.aid,info->senderGUID.oid);
      printf(":c:         topic: %s \n",info->topic);
      printf(":c:          type: %s \n",info->type);
	  printf(":c: localTimeRecv: sec = %d, fract = %d \n",
	         info->localTimeReceived.seconds,info->localTimeReceived.fraction);
      printf(":c: remoteTimePub: sec = %d, fract = %d \n",
	         info->remoteTimePublished.seconds,info->remoteTimePublished.fraction);
      printf(":c:         seqNr: high = %d, low = %d \n",info->sn.high,info->sn.low);
      printf("\n");
	#endif


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  obj_instance = (jobject)vinstance; //?? pujde to??
#ifdef TEST_STAGE
  if(!obj_instance) printf(":!c: pretypovani: (jobject)vinstance = NULL..\n");
   else printf(":c: pretypovani: (jobject)vinstance = %p OK ..\n", obj_instance);
#endif

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// -- vytvoreni parametru callback funkce ----------------------------------------end

  // call object's method
#ifdef TEST_STAGE
  printf(":c: volam callback metodu.. halo jsi tam?? \n\n");
#endif
  (*env)->CallVoidMethod(env,
                         callback_cont->obj, /*obj*/
	                     mid_callback,
                         callback_cont->rinfo,
			             obj_instance);

  if((*jvm)->DetachCurrentThread(jvm)!=0) printf("DetachCurrentThread fault\n");

#ifdef TEST_STAGE
  printf("\n");
  printf("-------------------- opoustim recvCallBack() z Ccka-------------------");
  printf("\n\n\n");
#endif
// --funkcni 05-01-13 ------------------------------------------------------------


}

// ### END recvCallBack() #####################################################




// ### nativni metoda #########################################################

JNIEXPORT jint JNICALL
Java_org_ocera_orte_Subscription_jORTESubscriptionCreate
(JNIEnv *env, jobject obj, jint dhandle, jint jsmode,
 jint jstype, jstring jtopic, jstring jtname, jint jbufflength,
 jobject jdeadline, jobject jminSeparation,
 jobject callbackObj /* recvCallBackparam  */, jlong j_multicastIP)
{
  ORTESubscription   *s;
  ORTEDomain         *d;
  SubscriptionMode    smode;
  SubscriptionType    stype;
  const char         *topic;
  const char         *typename;
  char               *instance;  // dynamicky naalokovat pole instance2send !!!!!
  NtpTime             deadline;
  NtpTime             minSeparation;

  JavaVM                *jvm;
  jfieldID fid;
  jclass cls;
  // callback_cont
  JORTECallbackContext_t *callback_cont = (JORTECallbackContext_t*)malloc(sizeof(JORTECallbackContext_t));
  //RecvInfoVar_t     *recvInfoVar   = (RecvInfoVar_t*)malloc(sizeof(RecvInfoVar_t));

  // bad/zero callbackObj
  if (callbackObj == 0)
  {
    printf(":c!: callbackObj can not be null.. \n");
    return 0;
  }

  // get jvm
  jint b = (*env)->GetJavaVM(env,&jvm);
  if (b <  0)
  {
    printf(":!c: getJavaVM() fault..\n");
    return 0;
  }
  if (b == 0)
  {
    #ifdef TEST_STAGE
      printf(":c: nativ fce: getJavaVM succesfull.. jvm = %p \n",jvm);
      printf(":c: nativ fce:                        env = %p \n",env);
    #endif
  }
  callback_cont->jvm = jvm;

  // create global reference
  callback_cont->obj = (*env)->NewGlobalRef(env, callbackObj);
  // global reference not created
  if (callback_cont->obj == 0)
  {
    printf(":!c: cannot create global reference obj_subsCallback ..\n");
    return 0;
  }

  // init RecvInfo pointer
  callback_cont->rinfo = 0;
  callback_cont->value = 0; // !!! JEN PRO TESTOVACI UCELY

#ifdef TEST_STAGE
  printf(":c: global reference obj_subsCallback created [%p] ..\n", callback_cont->obj);
  printf(":c: local  reference callbackObj              [%p] ..\n", callbackObj);
  printf(":c: global reference RecvInfo                 [%p] ..\n", callback_cont->rinfo);
#endif


// nastavi handle na stukturu callback_cont
  cls = (*env)->GetObjectClass(env, obj);
  fid = (*env)->GetFieldID(env, cls, "callbackContextHandle", "I");
  (*env)->SetIntField(env, obj, fid, (int)callback_cont);

// ---------------------------------------------------------------------------------------
//uz funkcni cast - bez recvCallbacku

  printf(":c: chystam se vytvorit subscribera..\n");
  d = (ORTEDomain *) dhandle;
  if (!d)
  {
    printf(":!c: jORTESubscriptionCreate bad domain handle.. \n ");
    return 0;
  }  //JavaVM          *jvm;

  smode = (SubscriptionMode) jsmode;
  stype = (SubscriptionType) jstype;
  topic = (*env)->GetStringUTFChars(env, jtopic, 0);
  typename = (*env)->GetStringUTFChars(env, jtname, 0);
  instance = (char *) malloc((int) jbufflength);
  deadline = getNtpTime(env, jdeadline);//
  minSeparation = getNtpTime(env, jminSeparation);//
  /* ... */
  /* ... */

  printf(":c: jORTESubscriptionreate() - nacteny parametry z javy..\n");

/*
ORTESubscriptionCreate(ORTEDomain *d,
                       SubscriptionMode mode,
                       SubscriptionType sType,
                       const char *topic,
                       const char *typeName,
                       void *instance,
                       NtpTime *deadline,
                       NtpTime *minimumSeparation,
                       ORTERecvCallBack recvCallBack,
                       void *recvCallBackParam,
                       IPAddress multicastIPAddress);

*/
  // call original liborte function
  s = ORTESubscriptionCreate(d,
                             smode,
                             stype,
                             topic,
                             typename,
                             &instance,
                             &deadline,
                             &minSeparation,
                             recvCallBack,
                             (void*)callback_cont,
                             (uint32_t) j_multicastIP);

  printf(":c: provedeno volani ORTESubscriptionCreate()..\n");

  if (!s) {
    printf(":!c: ORTESubscriptionCreate: bad publication handle.. \n ");
    return 0;
  }

  // free the memory
  (*env)->ReleaseStringUTFChars(env, jtopic, topic);
  (*env)->ReleaseStringUTFChars(env, jtname, typename);

  return ((jint) s);
}

